import customtkinter as CTk
import os
from typing_extensions import Self
from dataclasses import make_dataclass
from dataclasses import dataclass, field
import math
path = 'EOrec/'

@dataclass
class  ingredient (): # можно ещё добавить свойство "достаточно ли в наличии" или же "ингридиент произведён", при котором ингридиент не учитывается
  name: str
  needed_quantity: int
  production_per_run: int = 1
  run_needed: int = 0
  price: int = 0

@dataclass
class ingredients_list():
  ingredients: list[ingredient] = field(default_factory=list)

@dataclass
class player_charachteristics(): #задел под будущее
  material_efficienty: int = 20
  time_efficienty: int = 10

common_ingredient_list = ingredients_list() #список со множеством всех ингридиентов, с повторениями
total_ingredient_list = ingredients_list() #список со всеми ингридиентами, без повторений
file_doesnt_exsist = list() # = nonconstructable_list
already_producted = ingredients_list() #элемент добавляется сюда, если в наличии его больше, чем надо или если есть отметка что он уже произведёт(будет в будущем)
ingredients_in_warehouse = ingredients_list()
ingredients_in_warehouse_names = list()

for i in ingredients_in_warehouse.ingredients:
  ingredients_in_warehouse_names.append(i.name)

def read_recipe_file(reciepe_file): #читает файл и возвращает список классов с указанием ингридиента рецепта и требуемого количества
  first_ingredient_list = ingredients_list()
  with open(reciepe_file) as reciept:
    product_quantity = (int(reciept.readline().strip())) #по-факту уже пропуск первой строчки
    for line in reciept:
      parts = line.split(",") # создание частей строки из материнской по разделению запятой
      ingredient_name = parts[0].strip() #часть 1 до запятой
      #ingredient_quant = parts[1].strip() #часть 2 после запятой
      ingredient_name = ingredient(parts[0].strip(), int(parts[1].strip())) #создаём для каждой строчки свой класс, указывая имя и количество
      #ахахахаххахаха сука))0 первый баг. Если не указать тут int то получается str
      first_ingredient_list.ingredients.append(ingredient_name) # расщиряем список с ингредиентами
  return first_ingredient_list

def removing_duplicate_elements(input_list): #функция, которая удаляет повторяющиеся элементы из списка, прибавляя к существующим needed_quantity
  output_list = ingredients_list()
  inter_name_list = list()
  for i in input_list.ingredients:
    if i.name not in inter_name_list:
      inter_name_list.append(i.name)
      output_list.ingredients.append(i)
    else:
      for j in output_list.ingredients:
        if i.name == j.name:
          j.needed_quantity += i.needed_quantity
  return(output_list)

# Функция для расчета ингридиентов в следующем уровне
def next_list_generator(input_list, nonconstructable_list):
  pre_output_list = ingredients_list()
  output_list = ingredients_list()
  for i in input_list.ingredients:
    i = per_run(i)
    if os.path.exists(path + i.name + '.txt'):
      if i.name in ingredients_in_warehouse_names:
        for k in ingredients_in_warehouse:
          if k.name == i.name:
            i.needed_quantity -= k.needed_quantity
      else:
        inter_list = read_recipe_file(path + i.name + '.txt') #список для каждого отдельного рецепта
        i.run_needed = math.ceil(i.needed_quantity / i.production_per_run)
        for j in inter_list.ingredients:
          #j.needed_quantity = math.ceil(j.needed_quantity * (i.needed_quantity / i.production_per_run))
          j.needed_quantity = math.ceil(j.needed_quantity * i.run_needed)
          #print(j.name, j.needed_quantity, j.production_per_run, i.run_needed)
          pre_output_list.ingredients.append(j)
    else:
      nonconstructable_list.append(i.name)
    #print('_'*3)
  output_list = removing_duplicate_elements(pre_output_list)
  #output_list = pre_output_list
  return(output_list)

def per_run(element): #функция, берёт ингридиент, открывает файл с его рецептом, смотрит сколько производится за раз(первая строчка) и записывает это в класс ингридиента
  if os.path.exists(path + element.name + '.txt'):
    with open(path + element.name + '.txt') as reciept:
      element.production_per_run = (int(reciept.readline().strip())) #читает первую строчку
  return(element)

class App(CTk.CTk):
    def __init__(self):
        super().__init__()
        self.geometry('800x600')
        self.title('EveIndCalc 2')
        self.resizable(width= 'FALSE', height= 'FALSE')

        self.input_text_frame = CTk.CTkLabel(master = self,text = 'Bluprint:', width= 100, height= 20)
        self.input_text_frame.grid(row = 0, column = 0, padx=(10,20), pady =(10,20), sticky = "ew" )

        self.to_input_text_frame = CTk.CTkEntry(master = self, width= 200, height= 20, placeholder_text = 'What do you want?')
        self.to_input_text_frame.grid(row = 0, column = 1, padx=(10,20),pady =(10,20), sticky = "ew" )

        self.button_to_start = CTk.CTkButton(self, text ='Calculate', width = 50, height = 20, command = self.get_entry_data_by_button)
        self.button_to_start.grid(row = 0, column = 3,padx=(10,20),pady =(10,20), sticky = "ew" )
        self.to_produce = str()
        
    def get_entry_data_by_button(self):
        self.to_calculate_input = self.to_input_text_frame.get()
        print(self.to_calculate_input)
    
        


#class sheet():
#    print(1)
#text = 'Bluprint:'
aaa = 'cerberus'
if __name__ == '__main__':
    app = App()
    file_path = path + aaa + ".txt"
    first_list = read_recipe_file(file_path)
    second_list = next_list_generator(first_list, file_doesnt_exsist)
    third_list = next_list_generator(second_list, file_doesnt_exsist)
    fourth_list = next_list_generator(third_list, file_doesnt_exsist)
    all_list = [first_list,second_list,third_list,fourth_list]

    for i in all_list:
        for j in i.ingredients:
            common_ingredient_list.ingredients.append(j)
            total_ingredient_list = removing_duplicate_elements(common_ingredient_list)
    for i in total_ingredient_list.ingredients:
        print(i.name, i.needed_quantity, i.run_needed)

    for i in total_ingredient_list.ingredients:
        if not os.path.exists(path + i.name + '.txt') and i.name not in file_doesnt_exsist:
            file_doesnt_exsist.append(i.name)
    print('Рецепта не сущствует в папке!:', file_doesnt_exsist)
    



    app.mainloop()

